name: 'Deploy Complete NebengJek Stack'

on:
  push:
    branches: [main, development]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: ap-southeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-southeast-1.amazonaws.com
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}
  JWT_ACCESS_SECRET: ${{ secrets.JWT_ACCESS_SECRET }}
  JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
  GATEWAY_SECRET_KEY: ${{ secrets.GATEWAY_SECRET_KEY }}

  # ‚úÖ ENVIRONMENT-SPECIFIC INFRASTRUCTURE ENDPOINTS
  REDIS_HOST: ${{ github.ref_name == 'main' && secrets.PROD_REDIS_HOST || secrets.DEV_REDIS_HOST }}
  REDIS_PORT: ${{ github.ref_name == 'main' && secrets.PROD_REDIS_PORT || secrets.DEV_REDIS_PORT }}
  RDS_HOST: ${{ github.ref_name == 'main' && secrets.PROD_RDS_HOST || secrets.DEV_RDS_HOST }}
  RDS_PORT: ${{ github.ref_name == 'main' && secrets.PROD_RDS_PORT || secrets.DEV_RDS_PORT }}
  RDS_DATABASE: ${{ github.ref_name == 'main' && secrets.PROD_RDS_DATABASE || secrets.DEV_RDS_DATABASE }}
  RDS_USER: ${{ github.ref_name == 'main' && secrets.PROD_RDS_USER || secrets.DEV_RDS_USER }}
  RDS_PASSWORD: ${{ github.ref_name == 'main' && secrets.PROD_RDS_PASSWORD || secrets.DEV_RDS_PASSWORD }}

jobs:
  get-infrastructure:
    name: 'Get Infrastructure Info'
    runs-on: ubuntu-latest
    outputs:
      vpc-id: ${{ steps.get-vpc.outputs.vpc-id }}
      public-subnet-1: ${{ steps.get-vpc.outputs.public-subnet-1 }}
      public-subnet-2: ${{ steps.get-vpc.outputs.public-subnet-2 }}
      private-subnet-1: ${{ steps.get-vpc.outputs.private-subnet-1 }}
      private-subnet-2: ${{ steps.get-vpc.outputs.private-subnet-2 }}
      ecs-cluster: ${{ steps.deploy-ecs.outputs.ecs-cluster }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Display Environment Configuration
        run: |
          echo "üåç Deployment Configuration:"
          echo "   Environment: ${{ env.ENVIRONMENT }}"
          echo "   Branch: ${{ github.ref_name }}"
          echo "   Redis Host: ${{ env.REDIS_HOST }}"
          echo "   RDS Host: ${{ env.RDS_HOST }}"
          echo "   RDS Database: ${{ env.RDS_DATABASE }}"

      - name: Get VPC Information
        id: get-vpc
        run: |
          VPC_ID=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`VpcId`].OutputValue' --output text)
          PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' --output text)
          PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' --output text)
          PRIVATE_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet1`].OutputValue' --output text)
          PRIVATE_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet2`].OutputValue' --output text)

          echo "vpc-id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "public-subnet-1=$PUBLIC_SUBNET_1" >> $GITHUB_OUTPUT
          echo "public-subnet-2=$PUBLIC_SUBNET_2" >> $GITHUB_OUTPUT
          echo "private-subnet-1=$PRIVATE_SUBNET_1" >> $GITHUB_OUTPUT
          echo "private-subnet-2=$PRIVATE_SUBNET_2" >> $GITHUB_OUTPUT

      - name: Deploy ECS Cluster
        id: deploy-ecs
        run: |
          echo "üöÄ Deploying ECS Cluster for ${{ env.ENVIRONMENT }}..."

          aws cloudformation deploy \
            --template-file deployment/cloudformation/ecs-cluster.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-ecs-cluster \
            --parameter-overrides \
              Environment=${{ env.ENVIRONMENT }} \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          # Get ECS cluster name
          ECS_CLUSTER=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-ecs-cluster --query 'Stacks[0].Outputs[?OutputKey==`ClusterName`].OutputValue' --output text)
          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "‚úÖ ECS Cluster deployed: $ECS_CLUSTER"

  build-and-push:
    name: 'Build and Push All Services'
    runs-on: ubuntu-latest
    needs: get-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Create ECR repositories
        run: |
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")
          for service in "${services[@]}"; do
            aws ecr describe-repositories --repository-names $service 2>/dev/null || \
            aws ecr create-repository --repository-name $service
          done

      - name: Build and push all Docker images
        run: |
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")

          for service in "${services[@]}"; do
            echo "üê≥ Building $service for ${{ env.ENVIRONMENT }}..."
            
            if [ -f "./deployment/docker/$service.dockerfile" ]; then
              docker build -f ./deployment/docker/$service.dockerfile -t $service .
            else
              echo "‚ùå Dockerfile not found for $service"
              continue
            fi
            
            # Tag with environment-specific tags
            docker tag $service:latest $ECR_REGISTRY/$service:${{ env.ENVIRONMENT }}-${{ github.sha }}
            docker tag $service:latest $ECR_REGISTRY/$service:${{ env.ENVIRONMENT }}-latest
            
            
            echo "üì§ Pushing $service..."
            docker push $ECR_REGISTRY/$service:${{ env.ENVIRONMENT }}-latest
            docker push $ECR_REGISTRY/$service:${{ env.ENVIRONMENT }}-${{ github.sha }}
            
            echo "‚úÖ $service pushed successfully!"
          done

  deploy-kong:
    name: 'Deploy Kong Gateway'
    runs-on: ubuntu-latest
    needs: [get-infrastructure, build-and-push]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Kong Gateway
        run: |
          echo "üöÄ Deploying Kong Gateway for ${{ env.ENVIRONMENT }}..."

          aws cloudformation deploy \
            --template-file deployment/cloudformation/kong.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-kong \
            --parameter-overrides \
              Environment=${{ env.ENVIRONMENT }} \
              VpcId=${{ needs.get-infrastructure.outputs.vpc-id }} \
              PrivateSubnet1=${{ needs.get-infrastructure.outputs.private-subnet-1 }} \
              PrivateSubnet2=${{ needs.get-infrastructure.outputs.private-subnet-2 }} \
              PublicSubnet1=${{ needs.get-infrastructure.outputs.public-subnet-1 }} \
              PublicSubnet2=${{ needs.get-infrastructure.outputs.public-subnet-2 }} \
              ECSClusterName=${{ needs.get-infrastructure.outputs.ecs-cluster }} \
              DatabaseEndpoint=${{ env.RDS_HOST }} \
              DatabasePort=${{ env.RDS_PORT }} \
              DatabaseUsername=${{ env.RDS_USER }} \
              DatabasePassword=${{ env.RDS_PASSWORD }} \
              KongDatabaseName=kong \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          echo "‚úÖ Kong Gateway deployed successfully!"

  deploy-services:
    name: 'Deploy All Microservices'
    runs-on: ubuntu-latest
    needs: [get-infrastructure, build-and-push]
    strategy:
      matrix:
        service:
          - name: user-service
            uses_database: true
            uses_redis: true
          - name: booking-service
            uses_database: true
            uses_redis: true
          - name: tracking-service
            uses_database: true
            uses_redis: true
          - name: notification-service
            uses_database: true
            uses_redis: true
          - name: payment-service
            uses_database: true
            uses_redis: true
          - name: matching-service
            uses_database: false
            uses_redis: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy ${{ matrix.service.name }}
        run: |
          echo "üöÄ Deploying ${{ matrix.service.name }} to ${{ env.ENVIRONMENT }}..."

          # Check if CloudFormation template exists
          if [ ! -f "deployment/cloudformation/${{ matrix.service.name }}.yaml" ]; then
            echo "‚ùå CloudFormation template not found for ${{ matrix.service.name }}"
            exit 1
          fi

          # Build parameter overrides based on service requirements
          PARAMETERS="Environment=${{ env.ENVIRONMENT }} \
            VpcId=${{ needs.get-infrastructure.outputs.vpc-id }} \
            PrivateSubnet1=${{ needs.get-infrastructure.outputs.private-subnet-1 }} \
            PrivateSubnet2=${{ needs.get-infrastructure.outputs.private-subnet-2 }} \
            ECSClusterName=${{ needs.get-infrastructure.outputs.ecs-cluster }} \
            ECRRepository=${{ matrix.service.name }}"

          PARAMETERS="$PARAMETERS \
            ImageTag=${{ env.ENVIRONMENT }}-${{ github.sha }} \
            ExecutionRoleArn=arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }}-execution-role \
            TaskRoleArn=arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }}-task-role"

          # Add database parameters for services that use database
          if [ "${{ matrix.service.uses_database }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              DatabaseEndpoint=${{ env.RDS_HOST }} \
              DatabasePort=${{ env.RDS_PORT }} \
              DatabaseName=${{ env.RDS_DATABASE }} \
              DatabaseUsername=${{ env.RDS_USER }} \
              DatabasePassword=${{ env.RDS_PASSWORD }}"
          fi

          # Add Redis parameters for services that use Redis
          if [ "${{ matrix.service.uses_redis }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              RedisHost=${{ env.REDIS_HOST }} \
              RedisPort=${{ env.REDIS_PORT }}"
          fi

          if [ "${{ matrix.service.name }}" = "user-service" ]; then
            PARAMETERS="$PARAMETERS \
              JWTAccessSecret=${{ env.JWT_ACCESS_SECRET }} \
              JWTRefreshSecret=${{ env.JWT_REFRESH_SECRET }} \
              GatewaySecretKey=${{ env.GATEWAY_SECRET_KEY }}"
          fi

          aws cloudformation deploy \
            --template-file deployment/cloudformation/${{ matrix.service.name }}.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }} \
            --parameter-overrides $PARAMETERS \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          echo "‚úÖ ${{ matrix.service.name }} deployed successfully to ${{ env.ENVIRONMENT }}!"

  production-testing:
    name: 'Production Testing'
    runs-on: ubuntu-latest
    needs: [get-infrastructure, deploy-services, deploy-kong]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for services to be healthy
        run: |
          echo "‚è≥ Waiting for services to become healthy..."
          sleep 120  # Wait for services to start

      - name: Test External Infrastructure Connectivity
        run: |
          echo "üîç Testing ${{ env.ENVIRONMENT }} external infrastructure connectivity..."

          # Test database connection
          echo "üìä Testing PostgreSQL (${{ env.ENVIRONMENT }})..."
          sudo apt-get update -qq && sudo apt-get install -y postgresql-client
          export PGPASSWORD="${{ env.RDS_PASSWORD }}"
          if psql -h ${{ env.RDS_HOST }} -p ${{ env.RDS_PORT }} -U ${{ env.RDS_USER }} -d ${{ env.RDS_DATABASE }} -c "SELECT 1;" > /dev/null 2>&1; then
            echo "‚úÖ ${{ env.ENVIRONMENT }} PostgreSQL connection successful"
          else
            echo "‚ùå ${{ env.ENVIRONMENT }} PostgreSQL connection failed"
            exit 1
          fi

          # Test Redis connection
          echo "üî¥ Testing Redis (${{ env.ENVIRONMENT }})..."
          sudo apt-get install -y redis-tools
          if redis-cli -h ${{ env.REDIS_HOST }} -p ${{ env.REDIS_PORT }} ping | grep -q PONG; then
            echo "‚úÖ ${{ env.ENVIRONMENT }} Redis connection successful"
          else
            echo "‚ùå ${{ env.ENVIRONMENT }} Redis connection failed"
            exit 1
          fi

      - name: Generate Test Report
        run: |
          echo "üìä Environment: ${{ env.ENVIRONMENT }} Deployment Report"
          echo "=============================================="
          echo ""
          echo "üèóÔ∏è Infrastructure (${{ env.ENVIRONMENT }}):"
          echo "   ‚úÖ VPC: ${{ needs.get-infrastructure.outputs.vpc-id }}"
          echo "   ‚úÖ ECS Cluster: ${{ needs.get-infrastructure.outputs.ecs-cluster }}"
          echo "   ‚úÖ Redis: ${{ env.REDIS_HOST }}:${{ env.REDIS_PORT }}"
          echo "   ‚úÖ PostgreSQL: ${{ env.RDS_HOST }}"
          echo ""
          echo "üéâ ${{ env.ENVIRONMENT }} environment deployment successful!"
