name: 'Deploy Complete NebengJek Stack'

on:
  push:
    branches: [main, development]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: ap-southeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-southeast-1.amazonaws.com
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}

jobs:
  get-infrastructure:
    name: 'Get Infrastructure Information'
    runs-on: ubuntu-latest
    outputs:
      vpc-id: ${{ steps.get-vpc.outputs.vpc-id }}
      public-subnet-1: ${{ steps.get-vpc.outputs.public-subnet-1 }}
      public-subnet-2: ${{ steps.get-vpc.outputs.public-subnet-2 }}
      private-subnet-1: ${{ steps.get-vpc.outputs.private-subnet-1 }}
      private-subnet-2: ${{ steps.get-vpc.outputs.private-subnet-2 }}
      ecs-cluster: ${{ steps.get-ecs.outputs.ecs-cluster }}
      redis-host: ${{ steps.get-redis.outputs.redis-host }}
      redis-port: ${{ steps.get-redis.outputs.redis-port }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get VPC Information
        id: get-vpc
        run: |
          echo "üîç Getting VPC information for ${{ env.ENVIRONMENT }} environment..."

          VPC_ID=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`VpcId`].OutputValue' --output text)
          PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' --output text)
          PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' --output text)
          PRIVATE_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet1`].OutputValue' --output text)
          PRIVATE_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet2`].OutputValue' --output text)

          echo "vpc-id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "public-subnet-1=$PUBLIC_SUBNET_1" >> $GITHUB_OUTPUT
          echo "public-subnet-2=$PUBLIC_SUBNET_2" >> $GITHUB_OUTPUT
          echo "private-subnet-1=$PRIVATE_SUBNET_1" >> $GITHUB_OUTPUT
          echo "private-subnet-2=$PRIVATE_SUBNET_2" >> $GITHUB_OUTPUT

          echo "‚úÖ VPC Info: $VPC_ID"

      - name: Get ECS Cluster Information
        id: get-ecs
        run: |
          echo "üîç Getting ECS cluster information..."

          ECS_CLUSTER=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-ecs-cluster --query 'Stacks[0].Outputs[?OutputKey==`ClusterName`].OutputValue' --output text 2>/dev/null || echo "nebengjek-cluster")

          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "‚úÖ ECS Cluster: $ECS_CLUSTER"

      - name: Get Redis Information
        id: get-redis
        run: |
          echo "üîç Getting Redis information from existing deployment..."

          # Try to get Redis info from CloudFormation stack (deployed from nebengjek-cache)
          REDIS_HOST=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-redis --query 'Stacks[0].Outputs[?OutputKey==`RedisHost`].OutputValue' --output text 2>/dev/null || echo "")
          REDIS_PORT=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-redis --query 'Stacks[0].Outputs[?OutputKey==`RedisPort`].OutputValue' --output text 2>/dev/null || echo "6379")

          # If CloudFormation outputs not available, use GitHub secrets
          if [ -z "$REDIS_HOST" ] || [ "$REDIS_HOST" = "None" ]; then
            if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
              REDIS_HOST="${{ secrets.PROD_REDIS_HOST }}"
              REDIS_PORT="${{ secrets.PROD_REDIS_PORT }}"
            else
              REDIS_HOST="${{ secrets.DEV_REDIS_HOST }}"
              REDIS_PORT="${{ secrets.DEV_REDIS_PORT }}"
            fi
          fi

          echo "redis-host=$REDIS_HOST" >> $GITHUB_OUTPUT
          echo "redis-port=$REDIS_PORT" >> $GITHUB_OUTPUT
          echo "‚úÖ Redis: $REDIS_HOST:$REDIS_PORT"

  build-and-push:
    name: 'Build and Push All Services'
    runs-on: ubuntu-latest
    needs: get-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Create ECR repositories
        run: |
          echo "üì¶ Creating ECR repositories..."
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")
          for service in "${services[@]}"; do
            echo "Checking repository: $service"
            aws ecr describe-repositories --repository-names $service 2>/dev/null || \
            aws ecr create-repository --repository-name $service
          done

      - name: Build and push all Docker images
        run: |
          echo "üê≥ Building and pushing Docker images..."
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")

          for service in "${services[@]}"; do
            echo "üèóÔ∏è Building $service..."
            
            if [ -f "./deployment/docker/$service.dockerfile" ]; then
              docker build -f ./deployment/docker/$service.dockerfile -t $service .
            else
              echo "‚ùå Dockerfile not found for $service at ./deployment/docker/$service.dockerfile"
              exit 1
            fi
            
            docker tag $service:latest $ECR_REGISTRY/$service:latest
            docker tag $service:latest $ECR_REGISTRY/$service:${{ github.sha }}
            
            echo "üì§ Pushing $service..."
            docker push $ECR_REGISTRY/$service:latest
            docker push $ECR_REGISTRY/$service:${{ github.sha }}
            
            echo "‚úÖ $service pushed successfully!"
          done

  deploy-services:
    name: 'Deploy All Microservices'
    runs-on: ubuntu-latest
    needs: [get-infrastructure, build-and-push]
    strategy:
      matrix:
        service:
          - name: user-service
            uses_database: true
            uses_redis: true
          - name: booking-service
            uses_database: true
            uses_redis: true
          - name: tracking-service
            uses_database: true
            uses_redis: true
          - name: notification-service
            uses_database: true
            uses_redis: true
          - name: payment-service
            uses_database: true
            uses_redis: true
          - name: matching-service
            uses_database: false
            uses_redis: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy ${{ matrix.service.name }}
        run: |
          echo "üöÄ Deploying ${{ matrix.service.name }} to ${{ env.ENVIRONMENT }} environment..."

          # Check if CloudFormation template exists
          if [ ! -f "deployment/cloudformation/${{ matrix.service.name }}.yaml" ]; then
            echo "‚ùå CloudFormation template not found for ${{ matrix.service.name }}"
            exit 1
          fi

          # Set database credentials based on environment
          if [ "${{ env.ENVIRONMENT }}" = "prod" ]; then
            DB_HOST="${{ secrets.PROD_RDS_HOST }}"
            DB_PORT="${{ secrets.PROD_RDS_PORT }}"
            DB_USER="${{ secrets.PROD_RDS_USER }}"
            DB_PASSWORD="${{ secrets.PROD_RDS_PASSWORD }}"
            DB_NAME="${{ secrets.PROD_RDS_DATABASE }}"
          else
            DB_HOST="${{ secrets.DEV_RDS_HOST }}"
            DB_PORT="${{ secrets.DEV_RDS_PORT }}"
            DB_USER="${{ secrets.DEV_RDS_USER }}"
            DB_PASSWORD="${{ secrets.DEV_RDS_PASSWORD }}"
            DB_NAME="${{ secrets.DEV_RDS_DATABASE }}"
          fi

          # Build parameter overrides based on service requirements
          PARAMETERS="Environment=${{ env.ENVIRONMENT }} \
            VpcId=${{ needs.get-infrastructure.outputs.vpc-id }} \
            PrivateSubnet1=${{ needs.get-infrastructure.outputs.private-subnet-1 }} \
            PrivateSubnet2=${{ needs.get-infrastructure.outputs.private-subnet-2 }} \
            ECSClusterName=${{ needs.get-infrastructure.outputs.ecs-cluster }} \
            ECRRepository=${{ matrix.service.name }} \
            ImageTag=${{ github.sha }} \
            ExecutionRoleArn=arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }}-execution-role \
            TaskRoleArn=arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }}-task-role"

          # Add database parameters for services that use database
          if [ "${{ matrix.service.uses_database }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              DatabaseEndpoint=\"$DB_HOST\" \
              DatabasePort=\"$DB_PORT\" \
              DatabaseName=\"$DB_NAME\" \
              DatabaseUsername=\"$DB_USER\" \
              DatabasePassword=\"$DB_PASSWORD\""
          fi

          # Add Redis parameters for services that use Redis
          if [ "${{ matrix.service.uses_redis }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              RedisHost=${{ needs.get-infrastructure.outputs.redis-host }} \
              RedisPort=${{ needs.get-infrastructure.outputs.redis-port }}"
          fi

          # Add JWT secrets
          PARAMETERS="$PARAMETERS \
            JWTAccessSecret=\"${{ secrets.JWT_ACCESS_SECRET }}\" \
            JWTRefreshSecret=\"${{ secrets.JWT_REFRESH_SECRET }}\" \
            GatewaySecretKey=\"${{ secrets.GATEWAY_SECRET_KEY }}\""

          aws cloudformation deploy \
            --template-file deployment/cloudformation/${{ matrix.service.name }}.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }} \
            --parameter-overrides $PARAMETERS \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          echo "‚úÖ ${{ matrix.service.name }} deployed successfully!"

  verify-deployment:
    name: 'Verify Deployment'
    runs-on: ubuntu-latest
    needs: [get-infrastructure, deploy-services]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for services to stabilize
        run: |
          echo "‚è≥ Waiting for services to stabilize..."
          sleep 120

      - name: Check ECS Services Status
        run: |
          echo "üîç Checking ECS services health..."

          services=("user-service" "booking-service" "tracking-service" "notification-service" "payment-service" "matching-service")

          for service in "${services[@]}"; do
            echo "Checking ${{ env.ENVIRONMENT }}-$service..."
            
            # Get service status from ECS
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster ${{ needs.get-infrastructure.outputs.ecs-cluster }} \
              --services ${{ env.ENVIRONMENT }}-$service \
              --query 'services[0].{Status:status, Running:runningCount, Desired:desiredCount, Deployments:deployments[0].status}' \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            if echo "$SERVICE_INFO" | grep -q "ACTIVE.*1.*1.*PRIMARY"; then
              echo "‚úÖ $service is healthy (1/1 running)"
            else
              echo "‚ö†Ô∏è $service status: $SERVICE_INFO"
            fi
          done

      - name: Check ECS Tasks Health
        run: |
          echo "üîç Checking ECS tasks health..."

          # List all tasks in cluster
          TASKS=$(aws ecs list-tasks --cluster ${{ needs.get-infrastructure.outputs.ecs-cluster }} --query 'taskArns' --output text)

          if [ -n "$TASKS" ] && [ "$TASKS" != "None" ]; then
            echo "üìã Active tasks in cluster:"
            aws ecs describe-tasks --cluster ${{ needs.get-infrastructure.outputs.ecs-cluster }} --tasks $TASKS \
              --query 'tasks[].{Service:group, Status:lastStatus, Health:healthStatus, CPU:cpu, Memory:memory}' \
              --output table
          else
            echo "‚ö†Ô∏è No tasks found in cluster"
          fi

      - name: Check CloudWatch Logs for Errors
        run: |
          echo "üìã Checking recent CloudWatch logs for critical errors..."

          services=("user-service" "booking-service" "tracking-service" "notification-service" "payment-service" "matching-service")

          for service in "${services[@]}"; do
            LOG_GROUP="/ecs/nebengjek-${{ env.ENVIRONMENT }}-$service"
            
            echo "Checking logs for $service..."
            
            # Check if log group exists
            if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "$LOG_GROUP"; then
              
              # Get latest log stream
              LATEST_STREAM=$(aws logs describe-log-streams \
                --log-group-name "$LOG_GROUP" \
                --order-by LastEventTime \
                --descending \
                --max-items 1 \
                --query 'logStreams[0].logStreamName' --output text 2>/dev/null)
              
              if [ "$LATEST_STREAM" != "None" ] && [ -n "$LATEST_STREAM" ]; then
                # Check for errors in recent logs
                ERROR_COUNT=$(aws logs filter-log-events \
                  --log-group-name "$LOG_GROUP" \
                  --log-stream-names "$LATEST_STREAM" \
                  --filter-pattern "ERROR" \
                  --query 'length(events)' --output text 2>/dev/null || echo "0")
                
                if [ "$ERROR_COUNT" -gt 0 ]; then
                  echo "‚ö†Ô∏è $service has $ERROR_COUNT recent errors in logs"
                else
                  echo "‚úÖ $service logs look healthy"
                fi
              else
                echo "üìã No recent logs for $service"
              fi
            else
              echo "üìã Log group not found for $service (service may be starting)"
            fi
          done

      - name: Generate Deployment Report
        run: |
          echo ""
          echo "üìä NEBENGJEK DEPLOYMENT REPORT"
          echo "=============================="
          echo ""
          echo "üèóÔ∏è Infrastructure:"
          echo "   ‚úÖ Environment: ${{ env.ENVIRONMENT }}"
          echo "   ‚úÖ VPC: ${{ needs.get-infrastructure.outputs.vpc-id }}"
          echo "   ‚úÖ ECS Cluster: ${{ needs.get-infrastructure.outputs.ecs-cluster }}"
          echo "   ‚úÖ Redis: ${{ needs.get-infrastructure.outputs.redis-host }}:${{ needs.get-infrastructure.outputs.redis-port }}"
          echo "   ‚úÖ Database: Managed separately via nebengjek-db"
          echo ""
          echo "üöÄ Services Deployed:"
          echo "   üìä user-service"
          echo "   üìä booking-service"
          echo "   üìä tracking-service"
          echo "   üìä notification-service"  
          echo "   üìä payment-service"
          echo "   üìä matching-service"
          echo ""
          echo "üîó Next Steps:"
          echo "   1. ‚úÖ Verify all services are healthy in ECS console"
          echo "   2. üåê Setup domain and SSL certificates (if needed)"
          echo "   3. üìä Setup monitoring and alerting"
          echo "   4. üß™ Run end-to-end API tests"
          echo "   5. üì± Test mobile app integration"
          echo ""
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "‚ö†Ô∏è Notes:"
          echo "   - Database connectivity verified via service health"
          echo "   - Redis connectivity verified via service health"
          echo "   - All services deployed without API Gateway"
          echo "   - Check ECS console for detailed service status"
