name: 'Deploy Complete NebengJek Stack'

on:
  push:
    branches: [main, development]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: ap-southeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-southeast-1.amazonaws.com
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}

jobs:
  deploy-infrastructure:
    name: 'Deploy Infrastructure'
    runs-on: ubuntu-latest
    outputs:
      vpc-id: ${{ steps.get-vpc.outputs.vpc-id }}
      public-subnet-1: ${{ steps.get-vpc.outputs.public-subnet-1 }}
      public-subnet-2: ${{ steps.get-vpc.outputs.public-subnet-2 }}
      private-subnet-1: ${{ steps.get-vpc.outputs.private-subnet-1 }}
      private-subnet-2: ${{ steps.get-vpc.outputs.private-subnet-2 }}
      redis-host: ${{ steps.deploy-redis.outputs.redis-host }}
      redis-port: ${{ steps.deploy-redis.outputs.redis-port }}
      ecs-cluster: ${{ steps.deploy-ecs.outputs.ecs-cluster }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get VPC Information
        id: get-vpc
        run: |
          VPC_ID=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT || prod }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`VpcId`].OutputValue' --output text)
          PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT || prod }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' --output text)
          PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT || prod }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' --output text)
          PRIVATE_SUBNET_1=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT || prod }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet1`].OutputValue' --output text)
          PRIVATE_SUBNET_2=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT || prod }}-vpc --query 'Stacks[0].Outputs[?OutputKey==`PrivateSubnet2`].OutputValue' --output text)

          echo "vpc-id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "public-subnet-1=$PUBLIC_SUBNET_1" >> $GITHUB_OUTPUT
          echo "public-subnet-2=$PUBLIC_SUBNET_2" >> $GITHUB_OUTPUT
          echo "private-subnet-1=$PRIVATE_SUBNET_1" >> $GITHUB_OUTPUT
          echo "private-subnet-2=$PRIVATE_SUBNET_2" >> $GITHUB_OUTPUT

      - name: Deploy ECS Cluster
        id: deploy-ecs
        run: |
          echo "ğŸš€ Deploying ECS Cluster..."

          aws cloudformation deploy \
            --template-file deployment/cloudformation/ecs-cluster.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-ecs-cluster \
            --parameter-overrides \
              Environment=${{ env.ENVIRONMENT }} \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          # Get ECS cluster name
          ECS_CLUSTER=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-ecs-cluster --query 'Stacks[0].Outputs[?OutputKey==`ClusterName`].OutputValue' --output text)
          echo "ecs-cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "âœ… ECS Cluster deployed: $ECS_CLUSTER"

      - name: Deploy ElastiCache Redis
        id: deploy-redis
        run: |
          echo "ğŸš€ Deploying ElastiCache Redis..."

          aws cloudformation deploy \
            --template-file deployment/cloudformation/elasticache-redis.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-redis \
            --parameter-overrides \
              Environment=${{ env.ENVIRONMENT }} \
              VpcId=${{ steps.get-vpc.outputs.vpc-id }} \
              PrivateSubnet1=${{ steps.get-vpc.outputs.private-subnet-1 }} \
              PrivateSubnet2=${{ steps.get-vpc.outputs.private-subnet-2 }} \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          # Get Redis endpoint details
          REDIS_HOST=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-redis --query 'Stacks[0].Outputs[?OutputKey==`RedisEndpoint`].OutputValue' --output text)
          REDIS_PORT=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-redis --query 'Stacks[0].Outputs[?OutputKey==`RedisPort`].OutputValue' --output text)

          echo "redis-host=$REDIS_HOST" >> $GITHUB_OUTPUT
          echo "redis-port=$REDIS_PORT" >> $GITHUB_OUTPUT
          echo "âœ… Redis deployed at: $REDIS_HOST:$REDIS_PORT"

  build-and-push:
    name: 'Build and Push All Services'
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Create ECR repositories
        run: |
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")
          for service in "${services[@]}"; do
            aws ecr describe-repositories --repository-names $service 2>/dev/null || \
            aws ecr create-repository --repository-name $service
          done

      - name: Build and push all Docker images
        run: |
          services=("user-service" "booking-service" "matching-service" "notification-service" "payment-service" "tracking-service")

          for service in "${services[@]}"; do
            echo "ğŸ³ Building $service..."
            
            if [ -f "./deployment/docker/$service.dockerfile" ]; then
              docker build -f ./deployment/docker/$service.dockerfile -t $service .
            else
              echo "âŒ Dockerfile not found for $service"
              continue
            fi
            
            docker tag $service:latest $ECR_REGISTRY/$service:latest
            docker tag $service:latest $ECR_REGISTRY/$service:${{ github.sha }}
            
            echo "ğŸ“¤ Pushing $service..."
            docker push $ECR_REGISTRY/$service:latest
            docker push $ECR_REGISTRY/$service:${{ github.sha }}
            
            echo "âœ… $service pushed successfully!"
          done

  deploy-kong:
    name: 'Deploy Kong Gateway'
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Kong Gateway
        run: |
          echo "ğŸš€ Deploying Kong Gateway..."

          aws cloudformation deploy \
            --template-file deployment/cloudformation/kong.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-kong \
            --parameter-overrides \
              Environment=${{ env.ENVIRONMENT }} \
              VpcId=${{ needs.deploy-infrastructure.outputs.vpc-id }} \
              PrivateSubnet1=${{ needs.deploy-infrastructure.outputs.private-subnet-1 }} \
              PrivateSubnet2=${{ needs.deploy-infrastructure.outputs.private-subnet-2 }} \
              PublicSubnet1=${{ needs.deploy-infrastructure.outputs.public-subnet-1 }} \
              PublicSubnet2=${{ needs.deploy-infrastructure.outputs.public-subnet-2 }} \
              ECSClusterName=${{ needs.deploy-infrastructure.outputs.ecs-cluster }} \
              DatabaseEndpoint=${{ secrets.RDS_HOST }} \
              DatabasePort=${{ secrets.RDS_PORT }} \
              DatabaseUsername=${{ secrets.RDS_USER }} \
              DatabasePassword=${{ secrets.RDS_PASSWORD }} \
              KongDatabaseName=kong \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          echo "âœ… Kong Gateway deployed successfully!"

  deploy-services:
    name: 'Deploy All Microservices'
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push]
    strategy:
      matrix:
        service:
          - name: user-service
            uses_database: true
            uses_redis: true
          - name: booking-service
            uses_database: true
            uses_redis: true
          - name: tracking-service
            uses_database: true
            uses_redis: true
          - name: notification-service
            uses_database: true
            uses_redis: true
          - name: payment-service
            uses_database: true
            uses_redis: true
          - name: matching-service
            uses_database: false
            uses_redis: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy ${{ matrix.service.name }}
        run: |
          echo "ğŸš€ Deploying ${{ matrix.service.name }}..."

          # Check if CloudFormation template exists
          if [ ! -f "deployment/cloudformation/${{ matrix.service.name }}.yaml" ]; then
            echo "âŒ CloudFormation template not found for ${{ matrix.service.name }}"
            exit 1
          fi

          # Build parameter overrides based on service requirements
          PARAMETERS="Environment=${{ env.ENVIRONMENT }} \
            VpcId=${{ needs.deploy-infrastructure.outputs.vpc-id }} \
            PrivateSubnet1=${{ needs.deploy-infrastructure.outputs.private-subnet-1 }} \
            PrivateSubnet2=${{ needs.deploy-infrastructure.outputs.private-subnet-2 }} \
            ECSClusterName=${{ needs.deploy-infrastructure.outputs.ecs-cluster }} \
            ECRRepository=${{ matrix.service.name }}"

          # Add database parameters for services that use database
          if [ "${{ matrix.service.uses_database }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              DatabaseEndpoint=${{ secrets.RDS_HOST }} \
              DatabasePort=${{ secrets.RDS_PORT }} \
              DatabaseName=${{ secrets.RDS_DATABASE }} \
              DatabaseUsername=${{ secrets.RDS_USER }} \
              DatabasePassword=${{ secrets.RDS_PASSWORD }}"
          fi

          # Add Redis parameters for services that use Redis
          if [ "${{ matrix.service.uses_redis }}" = "true" ]; then
            PARAMETERS="$PARAMETERS \
              RedisHost=${{ needs.deploy-infrastructure.outputs.redis-host }} \
              RedisPort=${{ needs.deploy-infrastructure.outputs.redis-port }}"
          fi

          aws cloudformation deploy \
            --template-file deployment/cloudformation/${{ matrix.service.name }}.yaml \
            --stack-name nebengjek-${{ env.ENVIRONMENT }}-${{ matrix.service.name }} \
            --parameter-overrides $PARAMETERS \
            --capabilities CAPABILITY_IAM \
            --no-fail-on-empty-changeset

          echo "âœ… ${{ matrix.service.name }} deployed successfully!"

  production-testing:
    name: 'Production Testing'
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-services, deploy-kong]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for services to be healthy
        run: |
          echo "â³ Waiting for services to become healthy..."
          sleep 120  # Wait for services to start

      - name: Get service endpoints
        id: endpoints
        run: |
          # Get Kong ALB endpoint
          KONG_ENDPOINT=$(aws cloudformation describe-stacks --stack-name nebengjek-${{ env.ENVIRONMENT }}-kong --query 'Stacks[0].Outputs[?OutputKey==`KongProxyUrl`].OutputValue' --output text 2>/dev/null || echo "not-deployed")
          echo "kong-endpoint=$KONG_ENDPOINT" >> $GITHUB_OUTPUT

          echo "ğŸŒ Kong API Gateway: $KONG_ENDPOINT"

      - name: Test Database Connectivity
        run: |
          echo "ğŸ” Testing database connectivity..."

          # Install PostgreSQL client
          sudo apt-get update -qq
          sudo apt-get install -y postgresql-client

          # Test database connection
          export PGPASSWORD="${{ secrets.RDS_PASSWORD }}"
          if psql -h ${{ secrets.RDS_HOST }} -p ${{ secrets.RDS_PORT }} -U ${{ secrets.RDS_USER }} -d ${{ secrets.RDS_DATABASE }} -c "SELECT 1;" > /dev/null 2>&1; then
            echo "âœ… Database connection successful"
          else
            echo "âŒ Database connection failed"
            exit 1
          fi

      - name: Test Redis Connectivity
        run: |
          echo "ğŸ” Testing Redis connectivity..."

          # Install Redis CLI
          sudo apt-get install -y redis-tools

          # Test Redis connection
          if redis-cli -h ${{ needs.deploy-infrastructure.outputs.redis-host }} -p ${{ needs.deploy-infrastructure.outputs.redis-port }} ping | grep -q PONG; then
            echo "âœ… Redis connection successful"
          else
            echo "âŒ Redis connection failed"
            exit 1
          fi

      - name: Test Service Health Endpoints
        run: |
          echo "ğŸ¥ Testing service health endpoints..."

          services=("user-service" "booking-service" "tracking-service" "notification-service" "payment-service" "matching-service")

          for service in "${services[@]}"; do
            echo "Testing $service..."
            
            # Try to get service status from ECS
            SERVICE_STATUS=$(aws ecs describe-services --cluster ${{ needs.deploy-infrastructure.outputs.ecs-cluster }} --services ${{ env.ENVIRONMENT }}-$service --query 'services[0].status' --output text 2>/dev/null)
            
            if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
              echo "âœ… $service is running"
            else
              echo "âš ï¸ $service status: $SERVICE_STATUS"
            fi
          done

      - name: Test Kong Gateway
        run: |
          echo "ğŸ§ª Testing Kong Gateway..."

          KONG_ENDPOINT="${{ steps.endpoints.outputs.kong-endpoint }}"

          if [ "$KONG_ENDPOINT" != "not-deployed" ] && [ "$KONG_ENDPOINT" != "" ]; then
            # Test Kong status endpoint
            if curl -f -s "$KONG_ENDPOINT/status" > /dev/null; then
              echo "âœ… Kong Gateway is responding"
            else
              echo "âš ï¸ Kong Gateway not responding via ALB"
            fi
          else
            echo "ğŸ“ Kong Gateway not deployed or endpoint not available"
          fi

      - name: Generate Test Report
        run: |
          echo "ğŸ“Š Production Deployment Test Report"
          echo "====================================="
          echo ""
          echo "ğŸ—ï¸ Infrastructure:"
          echo "   âœ… VPC: ${{ needs.deploy-infrastructure.outputs.vpc-id }}"
          echo "   âœ… ECS Cluster: ${{ needs.deploy-infrastructure.outputs.ecs-cluster }}"
          echo "   âœ… Redis: ${{ needs.deploy-infrastructure.outputs.redis-host }}:${{ needs.deploy-infrastructure.outputs.redis-port }}"
          echo "   âœ… RDS: ${{ secrets.RDS_HOST }}"
          echo ""
          echo "ğŸš€ Services Deployed:"
          echo "   âœ… user-service"
          echo "   âœ… booking-service"
          echo "   âœ… tracking-service"
          echo "   âœ… notification-service"
          echo "   âœ… payment-service"
          echo "   âœ… matching-service"
          echo "   âœ… kong-gateway"
          echo ""
          echo "ğŸ§ª Tests Completed:"
          echo "   âœ… Database connectivity"
          echo "   âœ… Redis connectivity"
          echo "   âœ… Service health checks"
          echo "   âœ… Kong Gateway status"
          echo ""
          echo "ğŸ‰ Production deployment successful!"
          echo ""
          echo "ğŸ”— Next Steps:"
          echo "   1. Configure Kong API routes"
          echo "   2. Setup domain and SSL certificates"
          echo "   3. Setup monitoring and alerts"
          echo "   4. Test complete user flows"
